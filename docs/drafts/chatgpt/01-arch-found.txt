Stage 1 — Architecture & Foundations
Step 2: Define the system architecture and boundaries

Goal: Create a clear mental and written model of the app so humans and AI tools know where things belong.

No implementation yet — this step prevents spaghetti later.

Deliverables

docs/stages/stage-01-architecture.md

One high-level architecture diagram (ASCII is fine)

Clear module boundaries

Architecture style

Event-driven, core + adapters

Think:

Core = state + logic

UI = pure rendering

Backend services = adapters (K8s, terminal, plugins)

This keeps context small and testable.

Top-level components
+-----------------------+
|        TUI            |
|  (zellij-like UI)     |
+-----------+-----------+
            |
            v
+-----------------------+
|     App Core          |
|  State + Commands     |
+-----------+-----------+
            |
   +--------+--------+
   |                 |
   v                 v
+--------+     +-------------+
| K8s    |     | Plugin Host |
| Client |     | (WASM/Dylib)|
+--------+     +-------------+
            |
            v
     +----------------+
     | Internal Term  |
     | (Context-Aware)|
     +----------------+

Module boundaries (write this explicitly)
## Modules

### app_core
- Owns global state
- Dispatches commands
- No UI code
- No Kubernetes API calls directly

### ui
- Renders state
- Handles keyboard input
- Zero business logic

### k8s
- Wraps kube-rs
- Provides cluster, pod, exec, logs APIs
- No UI awareness

### terminal
- Context-aware shell
- Injects KUBECONFIG + context
- No Kubernetes logic (uses k8s module)

### plugins
- Defines plugin API
- Loads plugins
- Sandboxes execution

### config
- Keyboard shortcuts
- Feature flags
- User preferences

Command flow (important for AI tools)
Keyboard Input
   ↓
Command (enum)
   ↓
App Core
   ↓
State Mutation / Side Effect
   ↓
UI Re-render


No module skips this flow.

Design rules (non-negotiable)

Add these verbatim to the doc:

## Design Rules
- UI never mutates state directly
- All actions go through Commands
- Kubernetes access only via k8s module
- Terminal is context-aware but stateless
- Plugins cannot crash the core

YouTube video for this step

Title:

“Designing a Kubernetes TUI IDE Architecture (Before Writing Code)”

Content outline:

Why event-driven

How this keeps AI context small

Why UI must be dumb

How plugins stay safe

Success criteria

You can point to any future feature and say which module it belongs to

An AI tool can load only stage-01-architecture.md and still help correctly

